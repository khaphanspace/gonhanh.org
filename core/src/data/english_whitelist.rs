//! English Whitelist for Auto-Restore
//!
//! Contains ~3000 English words that need explicit whitelist for auto-restore.
//! These are words where the engine produces Vietnamese output but should restore
//! to English when space is pressed.
//!
//! Generated by: cargo test --test english_whitelist_generator -- --ignored
//! Source: 100K most common English words filtered for conflicts

/// Raw whitelist data (one word per line, sorted)
const WHITELIST_DATA: &str = include_str!("english_whitelist.txt");

/// Sorted whitelist for binary search lookup
/// Lazily initialized on first access
static WHITELIST: std::sync::OnceLock<Vec<&'static str>> = std::sync::OnceLock::new();

/// Get or initialize the sorted whitelist
fn get_whitelist() -> &'static Vec<&'static str> {
    WHITELIST.get_or_init(|| {
        let mut words: Vec<&str> = WHITELIST_DATA
            .lines()
            .filter(|line| !line.is_empty() && !line.starts_with("//"))
            .collect();
        words.sort_unstable();
        words
    })
}

/// Check if a word is in the English whitelist
///
/// Uses binary search for O(log n) lookup (~12 comparisons for 3000 words)
///
/// # Arguments
/// * `word` - The word to check (should be lowercase ASCII)
///
/// # Returns
/// `true` if the word is in the whitelist
pub fn contains(word: &str) -> bool {
    get_whitelist().binary_search(&word).is_ok()
}

/// Get the number of words in the whitelist
pub fn len() -> usize {
    get_whitelist().len()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_whitelist_loaded() {
        assert!(len() > 2000, "Whitelist should have 2000+ words");
        println!("Whitelist loaded: {} words", len());
    }

    #[test]
    fn test_common_words_in_whitelist() {
        // These common English words should be in whitelist
        let expected = ["of", "is", "as", "or", "if", "was", "her", "his", "has"];
        for word in expected {
            assert!(contains(word), "'{}' should be in whitelist", word);
        }
    }

    #[test]
    fn test_vietnamese_words_not_in_whitelist() {
        // Vietnamese words should NOT be in whitelist
        let not_expected = ["ba", "me", "anh", "em", "con", "nguoi"];
        for word in not_expected {
            assert!(!contains(word), "'{}' should NOT be in whitelist", word);
        }
    }

    #[test]
    fn test_binary_search_performance() {
        // Verify O(log n) by checking lookup doesn't timeout
        for _ in 0..10000 {
            let _ = contains("test");
            let _ = contains("nonexistent");
        }
    }
}
